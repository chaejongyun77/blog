# 유니온 파인드(Union-Find)란?

유니온-파인드 알고리즘은 집합을 결합(Union, 합집합)하고 해당 Element가 소속된 집합을 찾아내는(Find) 알고리즘이다.
서로소 집합(Disjoint-Set) 알고리즘이라고도 불린다.   

그래프에서도 유용하게 사용되어 노드 간의 연결 관계를 확인하는 등으로 응용되어 자주 사용된다. 
해당 알고리즘은 두 가지 기본 연산으로 구성된다.

- Union 연산: 여러 노드 중 두 노드를 선택하여 이들을 하나의 집합으로 연결한다. 이 연산을 통해 서로 연결된 노드들이 같은 집합에 속하게 된다.
- Find 연산: 특정 노드의 대표 노드를 찾아낸다. 두 노드의 대표 노드를 찾아낸다면 해당 노드들이 같은 집합에 속해 있는지를 확인할 수 있다.

## 유니온 파인드 목적

집합 소속 여부 판단: 임의의 두 노드가 동일한 집합에 속해 있는지를 확인할 수 있다. 그래프라면 임의의 두 노드가 연결되었는지 (탐색 가능한지)를 판단할 수 있다.

경로 압축: Find 연산 중 경로 압축 기법을 사용하여, 그래프 내에서 노드 간의 경로를 최적화한다. 이것은 그래프를 정돈하여 탐색 속도를 빠르게 하고 시간 복잡도를 향상시키는 목적으로도 사용할 수 있다.

싸이클 탐지: 그래프 탐색 중에 새로운 연결(Edge)이 싸이클을 형성하는지를 감지할 수 있다.

- 무방향 그래프에서만 적용이 가능하다.

## 유니온 파인드 과정

### STEP 1. 배열 초기화

![
유니온
](./img/union/union1.png)

### STEP 2. 유니온 연산

여러 노드 중 두 노드를 선택하여 이들을 하나의 집합으로 연결한다고 하였다. 
알고리즘 관점에서는 위에서 선언한 1차원 배열의 대표 노드를 갱신해주어 하나의 집합으로 묶는 과정이다.
이 때 유의할 점은 Union 연산 시 항상 대표 노드끼리를 연결해 주어야 한다는 것이다.

#### Union 연산 시 대표 노드가 자기 자신일 경우

![
유니온
](./img/union/union2.png)

해당 그림에서는 Union(1, 4)과 Union(2, 5)를 수행한다. 이 때 (1, 4), (2, 5)의 경우 현재는 대표 노드가 자기 자신이므로 그대로 Union을 진행해주면 된다. Union(1, 4)를 예시로 들어보자.

- 노드 1, 노드 4에서 find() 연산을 수행해도 대표 노드는 자기 자신이다.
- 따라서 곧바로 둘 중 하나의 대표 노드를 다른 쪽의 대표 노드로 설정한다.

#### 대표 노드가 자기 자신이 아닌 경우에서 Union

![
유니온
](./img/union/union3.png)

이번에는 Union(4, 6)의 연산을 수행해보자.

- 노드 4를 find() 연산을 수행하면 대표 노드는 1이다. (앞서 Union(1, 4)에서 변경된 상태)
- 노드 6에서도 find() 연산을 수행해보면 대표 노드로 5를 얻을 수 있다.
- 이 경우, 각각의 대표 노드(1과 5)를 비교하여 Union 연산을 수행한다.
- 노드 1의 대표 노드를 노드 5로 설정한다.

### STEP 3. 유니온 연산

![
유니온
](./img/union/union4.png)

특정 노드의 대표 노드를 찾아낸다. 두 노드의 대표 노드를 찾아낸다면 해당 노드들이 같은 집합에 속해 있는지를 확인할 수 있다.

연산 과정

- 대상 노드 배열의 index값과 value값이 동일한지 확인
- 동일하지 않으면 value값이 가리키는 index로 이동
- 재귀 함수로 구현 : index와 value값이 같을 때 까지 → 대표 노드를 찾을 때 까지 반복
- 재귀 함수를 빠져나오면서 거치는 모든 노드 값들을 루트 노드 값으로 변경
- 위 그림에서 Find()를 재귀적으로 대표 노드와 인덱스가 같은 값이 나올 때 까지 호출하여 루트 노드를 찾아내었다.
- 해당 노드의 인덱스를 재귀적으로 반환받으면서 자신의 parent값으로 설정한다.
- 결과로 반환되는 값은 해당 인덱스의 노드의 대표 노드에 해당한다.



문제 설명
네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다.

컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.

제한사항
컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다.
각 컴퓨터는 0부터 n-1인 정수로 표현합니다.
i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다.
computer[i][i]는 항상 1입니다.

출처 : https://school.programmers.co.kr/learn/courses/30/lessons/43162

```java

import java.util.*;
class Solution {
    static int[] unf;
    public int solution(int n, int[][] computers) {
       
        unf = new int[n+1];
        for(int i=1; i< unf.length; i++){
            unf[i] = i; 
        }
        for(int i=0; i<computers.length;i++){
            for(int j=0; j<computers[0].length;j++){
                if(i!=j && computers[i][j]==1){
                    Union(i+1,j+1);
                }

            }
        }
        
        Set<Integer> set = new HashSet();
        for(int i=1; i<unf.length; i++){
            int number = Find(i);
            set.add(number);
        }
      
        return set.size();
    }
    // 한 집합으로 만들어라
    public static void Union(int a, int b){
        int fa = Find(a);
        int fb = Find(b);
        if(fa!=fb) unf[fa]=fb;
    }
    
    // v번의 집합번호를 리턴
    public static int Find(int v){
        if(v==unf[v]) return v;
        else return unf[v] = Find(unf[v]);
    }
}

```
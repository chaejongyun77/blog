# 실시간 메시징 도입 배경
현재 저는 선생님과 학생이 같은 화면을 보며 실시간으로 소통할 수 있는 웹 기반 전자칠판 서비스를 개발·운영하고 있습니다.
전자칠판 서비스에서 실시간 메시징은 가장 중요한 기능 중 하나라고 생각합니다.

선생님이 전자칠판에 글을 작성하거나 도형을 추가하고 요소를 이동·삭제하는 순간 그 변화가 학생들의 화면에도 즉시 반영되어야 실제 수업과 같은 의사소통이 가능해지기 때문입니다.

즉, 한 사용자의 행동이 지연 없이 다른 사용자에게 전달되고 모든 사용자가 같은 상태의 화면을 공유해야 합니다.
이 요구사항을 만족하지 못한다면 전자칠판은 단순히 내용을 공유하는 일반적인 게시판에 불과합니다.

그래서 전자칠판 서비스에서는 **안정적이고 확장 가능한 실시간 메시징 구조**가 필요했고 이를 위해 **WebSocket + Kafka** 기반의 실시간 메시징 아키텍처를 구성하게 되었습니다.
이 글에서는 실제 서비스에서 이벤트가 어떤 흐름으로 전달되는지를 중심으로 전자칠판 서비스 내 실시간 메시징 처리가 어떻게 이루어지고 있는지 정리해보려 합니다.

***

<br>

# 실시간 이벤트 스트리밍 아키텍처 개요

전자칠판 서비스의 실시간 메시징은
WebSocket + Kafka를 중심으로 구성된 구조를 사용하고 있습니다.

![
kafka
](./img/kafka/kafka.jpeg)

전체 흐름을 단순화하면 다음과 같습니다

1. 클라이언트(선생님/학생)는 WebSocket을 통해 서버와 연결된다.
2. 사용자의 행동(게시물 작성, 이동, 삭제 등)은 WebSocket을 통해 서버로 전달된다.
3. 서버는 해당 이벤트를 Kafka로 전달한다.
4. Kafka는 메시지를 모든 서버 인스턴스에 전달한다.
5. 각 서버는 자신에게 연결된 클라이언트에게 WebSocket으로 메시지를 다시 전파한다.

이 구조를 통해 특정 서버 인스턴스에 종속되지 않고
여러 서버로 확장된 환경에서도 모든 사용자가 동일한 실시간 화면을 공유할 수 있습니다.

<br>

## 그럼 웹소켓은 무엇인가?
> 웹소켓이 왜 필요한건대?

![
websocket
](./img/kafka/websocket.gif)

웹 소켓은 HTML5에 등장 실시간 웹 애플리케이션을 위해 설계된 통신 프로토콜이며, TCP(Transmission Control Protocol)를 기반으로 합니다.  
TCP를 기반으로 한 웹 소켓은 신뢰성 있는 데이터 전송을 보장하며, 메시지 경계를 존중하고, 순서가 보장된 양방향 통신을 제공할 수 있습니다.  
HTTP와 다르게 클라이언트와 서버 간에 최초 연결이 이루어지면, 이 연결을 통해 양방향 통신을 지속적으로 할 수 있습니다.   

즉, 전화 통화와 같이 양쪽 모두에서 정보를 주고받을 수 있다는 의미입니다.   

이 '지속적 연결'을 통해서 서버는 클라이언트에게 실시간으로 데이터를 보낼 수 있으며, 반대로 클라이언트도 서버에게 데이터를 보낼 수 있습니다.
이때 데이터는 ‘패킷(packet)’ 형태로 전달되며, 전송은 연결 중단과 추가 HTTP 요청 없이 양방향으로 이뤄집니다.
또한 웹소켓 연결을 하려면 new WebSocket을 호출하면 되는데, 이때 ws라는 특수 프로토콜을 사용합니다.

```java
const socket = new WebSocket("ws://yong-nyong.tistory.com/socket");
```

### HTTP vs WebSocket 차이

| 구분 | HTTP | WebSocket |
|----|----|----|
| 연결 방식 | 요청-응답 | 연결 유지 |
| 연결 수명 | 요청마다 새로 | 한 번 연결 후 지속 |
| 통신 방향 | 단방향(요청 기반) | 양방향 |
| 서버 → 클라이언트 | 불가능 | 가능 |
| 실시간성 | 낮음 | 매우 높음 |

HTTP는 클라이언트의 요청이 있어야만 서버가 응답할 수 있는 구조인 반면 WebSocket은 연결을 유지한 채 서버와 클라이언트가 서로 자유롭게 메시지를 주고받을 수 있습니다.

>WebSocket은 하나의 TCP 연결을 유지한 채
클라이언트와 서버가 언제든지 메시지를 주고받을 수 있는
양방향 통신 프로토콜이다.

>기존 HTTP 통신은 클라이언트 요청이 있어야만
서버가 응답할 수 있는 구조이기 때문에
실시간 메시징 처리에는 한계가 있다.

>따라서 전자칠판 서비스에서는
선생님의 행동이 즉시 학생 화면에 반영되어야 하므로
서버가 클라이언트에게 즉시 메시지를 전달할 수 있는
WebSocket이 실시간 메시징의 핵심 역할을 한다.

<br>

### 하지만 웹소켓만 사용하면 한계를 만난다

#### WebSocket은 하나의 연결이 하나의 서버 인스턴스에 종속된다

WebSocket 연결은 특정 WAS 인스턴스에 종속되기 때문에 하나의 WebSocket 연결을 통해 여러 WAS 서버로 동시에 메시지를 전달할 수는 없습니다.

>WebSocket만으로 클라이언트가 WAS1, WAS2에 동시에 연결할 수 있나?

하나의 WebSocket 연결이 WAS-1에도 보내고 WAS-2에도 보내고 이런 구조는 WebSocket 만으로는 안됩니다.

<br>

#### 결국 WAS 서버가 여러 대일 때 문제가 생긴다
이 때문에 WAS 서버가 여러 대로 구성된 환경에서는 한 서버에서 발생한 WebSocket 메시지를
다른 서버가 직접 전달받을 수 없습니다.

따라서 이러한 한계를 해결하기 위해 **서버 간 메시지를 공유할 수 있는 Kafka를 도입했고   
모든 WAS 서버가 동일한 실시간 이벤트를 처리할 수 있도록 구성**했습니다.

***
<br>

## 카프카는 무엇인가?

카프카(Kafka)는 파이프라인, 스트리밍 분석, 데이터 통합 및 미션 크리티컬 애플리케이션을 위해 설계된 고성능 분산 이벤트 스트리밍 플랫폼이다.   
또한 Pub-Sub 모델의 메시지 큐 형태로 동작하며 분산환경에 특화되어 있습니다.

![
kafka
](./img/kafka/kafka2.png)

<br>

### 카프카의 동작 방식 및 특징
카프카는 Pub-Sub 모델의 메세지 큐 형태로 동작합니다.
우선 카프카를 이해하기 위해서는 이벤트 브로커와 메세지 큐에 대한 이해가 필요합니다.

<br>

#### 메세지 큐 (Message Queue, MQ) 란?   
메시지 큐는 메시지 지향 미들웨어(MOM : Message Oriented Middleware)를 구현한 시스템으로 프로그램(프로세스) 간의 데이터를 교환할 때 사용하는 기술이다.

![
kafka
](./img/kafka/kafka3.png)

<br>

- producer : 정보를 제공하는 자
- consumer : 정보를 제공받아서 사용하려는 자
- Queue : producer의 데이터를 임시 저장 및 consumer에 제공하는 곳

<br>

**Message Queue의 장점**   

1. 비동기: queue라는 임시 저장소가 있기 때문에 나중에 처리 가능
2. 낮은 결합도: 애플리케이션과 분리
3. 확장성: producer or consumer 서비스를 원하는대로 확장할 수 있음
4. 탄력성: consumer 서비스가 다운되더라도 애플리케이션이 중단되는 것은 아니며 메시지는 지속하여 MQ에 남아있다.
5. 보장성: MQ에 들어간다면 결국 모든 메시지가 consumer 서비스에게 전달된다는 보장을 제공한다.

<br>

#### 이벤트 브로커

이벤트 브로커 또한 기본적으로 메세지 브로커의 큐 기능들을 가지고 있어 메세지 브로커의 역할도 할 수 있습니다.
메세지 브로커와의 가장 큰 차이점은 이벤트 브로커는 publisher가 생산한 이벤트를 이벤트 처리 후에 바로 삭제하지 않고 저장하여 이벤트 시점이 저장되어 있어서 consumer가 특정 시점부터 이벤트를 다시 consume 할 수 있는 장점이 있다.
예를 들어 장애가 일어난 시점부터 그 이후의 이벤트를 다시 처리할 수 있습니다.

또한 대용량 처리에 있어서는 메세지 브로커보다는 더 많은 양의 데이터를 처리할 수 있는 능력이 있습니다.
여기서 Kafka는 이벤트 브로커에 해당됩니다.

<br>

#### 일반적인 메시지 통신과 차이

![
kafka
](./img/kafka/kafka4.png)

일반적인 메시지 통신은 각 개체가 직접 연결하며 통신하게 되는데 전송속도가 빠르고 전송 결과를 신속하게 알 수 있는 장점이 있는 반면에 특정 개체에 장애가 발생한 경우 메세지를 보내는 쪽에서 대기 처리 등을 개별적으로 해주지 않으면 장애가 전파될 수 있습니다.
또한 참여하는 개체가 많아질 수록 각 개체를 연결해줘야 합니다.


이러한 형태의 단점을 극복하고자 나온게 Pub/Sub 모델입니다.

![
kafka
](./img/kafka/kafka5.png)

Pub/Sub 모델은 비동기 메세징 전송 방식으로 발신자의 메세지에는 수신자가 정해져 있지 않은 상태로 publish 합니다.    
그리고 이를 Subscribe(구독)을 한 수신자만 정해진 메세지(topic)을 받을 수 있습니다.

이처럼 수신자는 발신자 정보가 없어도 원하는 메세지만 수신할 수 있으며 이런 구조 덕분에 높은 확장성을 확보할 수 있습니다.


<br>

### 카프카 구성 요소 및 특징

![
kafka
](./img/kafka/kafka6.png)

![
kafka
](./img/kafka/kafka7.png)


### 1. Topic ### 

- 각각의 메시지를 목적에 맞게 구분할 때 사용
- 메시지를 전송하거나 소비할 때 Topic을 반드시 입력한
- Consumer는 자신이 담당하는 Topic의 메시지를 처리
- 한 개의 토픽은 한 개 이상의 파티션으로 구성.

### 2. Partition ###

- 분산 처리를 위해 사용
- Topic 생성 시 partition 개수를 지정
- 파티션이 1개라면 모든 메시지에 대해 순서가 보장
- 파티션이 여러개라면 Kafka 클러스터가 라운드 로빈 방식으로 분배해서 분산처리되기 때문에 순서 보장 X
- 파티션 내부에서 각 메시지는 offset(고유 번호)로 구분
- 파티션이 많을 수록 처리량이 좋지만 장애 복구 시간이 늘어남

### 3. Offset ###

- 컨슈머에서 메세지를 어디까지 읽었는지 저장하는 값
- 컨슈머 그룹의 컨슈머들은 각각의 파티션에 자신이 가져간 메시지의 위치 정보(offset) 을 기록
- 컨슈머 장애 발생 후 다시 살아나도 전에 마지막으로 읽었던 위치에서부터 다시 읽음

### 4. Producer ###

- 메시지를 만들어서 카프카 클러스터에 전송
- key값을 지정하여 특정 파티션으로만 전송 가능
- 전송 acks값을 설정하여 효율성을 높일 수 있음


### 5. Consumer ###

- 카프카 클러스터에서 메시지를 읽어서 처리
- 한 개의 컨슈머는 여러 개의 토픽을 처리할 수 있음
- 메시지를 소비하여도 메시지를 삭제하지는 않음
- 한 번 저장된 메시지를 여러번 소비도 가능
- 컨슈머는 컨슈머 그룹에 속함

### 6. Broker ###

- 실행된 카프카 서버를 의미
- Broker(각 서버)는 Kafka Cluster 내부에 존재한다.
- 서버 내부에 메시지를 저장하고 관리하는 역할을 수행한다.

### 7. Zookeeper ###

- 분산 애플리케이션 관리를 위한 코디네이션 시스템
- 분산 메시지큐의 메타 정보를 중앙에서 관리하는 역할

<br>

#### Kafka VS Redis

| 구분 | Kafka | Redis Pub/Sub |
|---|---|---|
| 라우팅 | 기본 기능으로 라우팅을 지원하지 않음<br/>Kafka Streams 등을 활용해 동적 라우팅 구현 가능 | 라우팅 개념 없음 |
| 프로토콜 | TCP 기반 Custom 프로토콜 사용<br/>플랫폼 대체가 어려움 | RESP (Redis Serialization Protocol)<br/>TCP 기반 |
| 우선순위 | 변경 불가능한 시퀀스 큐 구조<br/>단일 파티션 내에서는 순서 보장<br/>여러 파티션 병렬 처리 시 전체 순서 보장 불가 | 우선순위 미지원<br/>이벤트 순서 및 도착 보장 불가 |
| 이벤트 저장 | 이벤트를 삭제하지 않고 디스크에 저장<br/>영속성(Durability) 보장<br/>재처리 가능 | 이벤트 저장하지 않음<br/>Subscriber가 없으면 이벤트 즉시 소멸 |
| 메시지 전달 보장 | Consumer가 읽어도 메시지 유지<br/>Offset 기반 재처리 가능 | 전달 보장 없음 |
| 장점 | - 이벤트를 디스크에 저장하여 안정적<br/>- 고성능, 고가용성, 분산 처리에 적합<br/>- 대용량 데이터 병렬 처리에 강점 | - 구조가 단순하고 가벼움<br/>- 채널을 구독한 모든 Subscriber가 이벤트 수신<br/>- 실시간 동기화 구조에 간단히 적용 가능 |
| 단점 | - 범용 메시징 시스템에 비해 기능 단순<br/>- 설정 및 운영 복잡도 높음 | - 이벤트 유실 가능성 높음<br/>- 장애 상황에서 신뢰성 낮음 |
| 주요 활용 사례 | 이벤트 스트리밍<br/>실시간 상태 동기화<br/>로그 수집 및 분석 | 단순 실시간 알림<br/>가벼운 Pub/Sub 통신 |


***
<br>

## 전자칠판 서비스에서의 Kafka 주요 설계 특징
> 저는 이렇게 설계했습니다.

### 1. 토픽 : 기능 단위로 분리

![
kafka
](./img/kafka/kafka8.png)

토픽별로 설정을 다르게 가져갈 수 있기 때문에 파티션을 기능별로 분리하였습니다.   

예를들어 실시간으로 사용자의 커서위치를 나타내는 기능은 파티션을 늘려 병렬로 처리하여 지연 최소화를 우선적으로 생각하였습니다.   

그러나 UndoRedo 기능같은 경우는 순서를 보장할 수 있게 컨슈머 동시성을 1로 설정하여 다른 파티션의 설정과 달리 가져갔습니다.

[사진첨부]
또한 기능별로 토픽을 나누면 모니터링도 기능별로 한눈에 파악할 수 있습니다.
이렇게 lag과 처리량등 기능단위로 추적하기 쉬워져서 장애 대응에 빨라질 수 있습니다.

<br>

### 2. 파티션과 Concurrency 설정

concurrency는 하나의 Kafka 리스너가 동시에 몇 개의 메시지를 병렬로 처리할지 정하는 설정이다.
보통 이 값은 해당 토픽의 파티션 수와 맞춰 효율을 내는 경우가 많습니다.
예를들어 concurrency = 3 이면 하나의 컨슈머 그룹 내에서 3개의 소비 스레드가 동시에 메시지를 처리한다.   

- 파티션 수가 concurrency보다 작으면 concurrency를 늘려도 남는 쓰레드가 생겨 효율이 떨어짐
- 파티션 수가 concurrency보다 크면 한 쓰레드가 여러 파티션을 처리해서 병목이 생길 수 있음
따라서 자신의 상황에 맞게 적절한 concurrency를 설정하는게 중요하다.

<br>

### 3. Key 추가하여 순서 보장

![
kafka
](./img/kafka/kafka9.png)

Kafka는 같은 파티션 안에서만 순서를 보장하는 분산 메시징 시스템입니다.    
속도를 내기 위해 하나의 토픽을 여러 개의 파티션(Partition) 으로 나누고 각 파티션을 병렬로 처리한다.

![
kafka
](./img/kafka/kafka11.png)

- 파티션 0 안에서는 → 순서 보장
- 파티션 1 안에서는 → 순서 보장 
- 파티션 0 ↔ 파티션 1 사이의 순서는 보장 X

즉 Kafka는 “전체 메시지 순서”가 아니라 “파티션 단위 순서”만 보장합니다.

> Key가 없으면 무슨 일이 생길까?

Kafka에 메시지를 보낼 때 key를 지정하지 않으면 Kafka는 메시지를 라운드 로빈 / 랜덤 방식으로 파티션에 분산시킵니다.
예를 들어 같은 보드에서 다음과 같은 이벤트가 발생했다고 가정해보겠습니다.

1. 게시물 생성 -> partition 0
2. 댓글 작성 -> partition 1
3. 좋아요 클릭 -> partition 2

컨슈머는 파티션을 병렬로 처리하기 때문에 댓글 작성 → 좋아요 클릭 → 게시물 생성과 같이 순서가 뒤죽박죽 섞여서 실행되는 치명적인 오류가 생길 수 있다.

> 그래서 Key를 쓰면 어떻게 되는건대?

Kafka에서 같은 key를 가진 메시지는 항상 같은 파티션으로 간다
예를들어 key가 "123"이면 항상 partition 1로 가고 key가 "456"이면 항상 항상 partition 2로 감

여기서 중요한건 게시판 내부에서 발생한 이벤트들의 순서가 중요하다고 생각했기 때문에 boardId를 key로 설정하였습니다.
따라서 같은 boardId는 항상 같은 파티션으로 메시지가 가고 **결과적으로는 보드 단위로 순서가 보장되는 실시간 이벤트 처리가 가능해집니다.**

<br>

### 4. GroupId 설정 : WAS 다중 환경에서 발생한 실시간 메시지 누락 이슈

단일 WAS 환경에서는 문제가 없었지만 WAS 서버가 was1, was2 두 대 이상으로 늘어나면서 이상한 현상이 발생했다
선생님(사용자1)이 게시글을 작성하면 사용자2(학생)는 실시간으로 보이는데 사용자3(학생)는 실시간으로 안 보이는 경우가 생겼다.

원인을 파악한 결과 WAS 서버들이 같은 Consumer Group으로 동작하고 있어서 메시지를 was1 또는 was2 중 한 곳만 소비하고 있는 현상이 문제였다.

참고로 Kafka에서 **consumer group은 “메시지를 나눠서 처리하는 단위”**다. 따라서 같은 groupId를 사용하는 컨슈머들은 토픽의 메시지를 서로 나눠서 소비한다

>WAS마다 서로 다른 groupId 사용하여 해결

이 문제를 해결하기 위해 WAS 서버마다 서로 다른 groupId를 사용하도록 변경했다. 

- was1 → groupId = prd-was1
- was2 → groupId = prd-was2

이렇게 설정하면 각 WAS는 토픽의 모든 메시지를 각각 소비할 수 있어서 실시간 이벤트를 정상적으로 수신할 수 있게 되었다.

<br>

***

### 마무리하며

gif

Kafka 운용 시 중요한 부분 중 하나는 Lag이 얼마나 쌓이는지 항상 모니터링하는 것입니다.   
Lag이란 Kafka에 미처리된 이벤트가 얼마나 남았는지에 대한 메트릭인데 테스트 과정에서 적정한 Consumer 개수와 Partition 개수를 정할 때 Lag을 보면서 설계해야 합니다.
시간으로 브로커 개수, 토픽 개수, 컨슈머 개수 등을 모니터링할 수 있어서 Lag을 관리하는 데 큰 도움을 받았습니다. 

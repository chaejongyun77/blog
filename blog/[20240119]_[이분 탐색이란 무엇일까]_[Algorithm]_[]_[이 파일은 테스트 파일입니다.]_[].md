# 이진탐색이란?

이진탐색은 데이터가 정렬되어 있는 상태에서 원하는 값을 찾아내는 알고리즘이다.
데이터의 중앙값과 찾고자 하는 값을 비교해 데이터의 크기를 절반씩 줄이면서 대상을 찾는 방식이다.

# 이진탐색 과정

![
이진탐색
](./img/binary/binary.gif)

- 배열의 ‘중간 값’을 선택하여 찾고자 하는 값과 비교합니다.

- 만약 중간 값이 찾고자 하는 값보다 크면 ‘배열 왼쪽 부분'에서 탐색을 진행하고, 값보다 작으면 ‘배열 오른쪽 부분'에서 탐색을 진행합니다.

- 이 과정에서 찾고자 하는 값이 나올 때까지 반복합니다.

## 이진 탐색과 선형 탐색의 차이점 

- 일반적으로 이진 탐색을 이용하여 값을 찾는 방법이 for문을 이용하는 것보다 빠릅니다.
- 이진 탐색은 정렬된 배열에서 원하는 값을 찾는 알고리즘이며, 중간값을 찾아 탐색 범위를 반으로 줄이면서 값을 찾아갑니다.
- 이에 비해 for문은 배열 전체를 순회하면서 값을 찾기 때문에, 배열의 크기와 상관없이 속도가 일정하게 증가합니다.


## 이진탐색 성능

![
이진탐색
](./img/binary/binary1.png)

| 표기법 | 이름 | 시간 복잡도 | 설명 | 예시 |
|------|------|-----------|------|------|
| O(1) | 상수 | 상수 시간 | 입력 크기와 상관없이 일정한 실행 시간을 가집니다. | 배열에서 원소 하나 찾기 |
| O(log n) | 로그 | 로그 시간 | 입력 크기가 증가함에 따라 실행 시간이 로그 함수 형태로 증가합니다. | 이진 탐색 알고리즘 |
| O(n) | 선형 | 선형 시간 | 입력 크기와 비례하는 실행 시간을 가집니다. | 선형 탐색 알고리즘 |
| O(n log n) | 로그 선형 | 선형 로그 시간 | 입력 크기에 따라 선형 × 로그 형태로 실행 시간이 증가합니다. | 병합 정렬, 힙 정렬 |
| O(n²) | 이차 | 이차 시간 | 입력 크기의 제곱에 비례하는 실행 시간을 가집니다. | 선택 정렬, 버블 정렬 |
| O(2ⁿ) | 지수 | 지수 시간 | 입력 크기의 지수에 비례하는 실행 시간을 가집니다. | 부분집합 탐색 |
| O(n!) | 계승 | 팩토리얼 시간 | 입력 크기의 팩토리얼에 비례하는 실행 시간을 가집니다. | 외판원 문제 |



## 이진탐색 문제풀이

n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.

처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.

모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

제한사항
입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
심사관은 1명 이상 100,000명 이하입니다.
입출력 예
n	times	return
6	[7, 10]	28
입출력 예 설명
가장 첫 두 사람은 바로 심사를 받으러 갑니다.

7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.

10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.

14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.

20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.

출처 : https://school.programmers.co.kr/learn/courses/30/lessons/43238


```java
import java.util.*;

class Solution {
    public long solution(int n, int[] times) {
        long answer = 0;
        Arrays.sort(times);
        long lt =1;
        long rt = (long)times[times.length-1] *n;
        
        while(lt<=rt){
            long mid = lt + (rt-lt)/2;
            long person = 0;
            for(int i=0; i<times.length; i++){
                person += mid / times[i];
            }
            
            if (person >= n){
                answer = mid;
                rt = mid -1;
            }
            else{
                lt = mid +1;
            }
            
        }
        return answer;
    }
}
```
